---
title: "viewscape"
date: "2023-10-08"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{viewscape}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Viewscape

This vignette provides a basic overview of the functions in R package `viewscape`.

The basic viewshed analysis can be accessed through calling the `compute_viewshed`. The two needed objects to compute the viewshed are a digital surface model (DSM) and a viewpoint.

### Compute viewshed

```{r eval=FALSE}
#Load in DSM
test_dsm <- raster::raster(system.file("test_dsm.tif", package ="viewscape"))

#Load in the viewpoint
test_viewpoint <- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))

#Transform viewpoint from shape file to coordinates 
test_viewpoint <- sf::st_coordinates(test_viewpoint)
test_viewpoint <- c(test_viewpoint[,1], test_viewpoint[,2])

#Compute viewshed
output <- viewscape::compute_viewshed(dsm = test_dsm, viewpoints = test_viewpoint, offset_viewpoint = 6, visualization=TRUE)
```

```{r}
# overlap viewshed on DSM
viewpoint <- matrix(0,1,3)
viewpoint[1,1] <- test_viewpoint[1]
viewpoint[1,2] <- test_viewpoint[2]
output[output[] == 0 ] = NA
raster::plot(test_dsm, axes=FALSE, box=FALSE, legend = FALSE)
raster::plot(output, add=TRUE, col = "red", axes=FALSE, box=FALSE, legend = FALSE)
raster::plot(sp::SpatialPoints(viewpoint), add = TRUE, col = "blue", axes=FALSE, box=FALSE, legend = FALSE)
```
# Compute the viewshed for multiple viewpoints

```{r}
#Load in DSM
test_dsm <- raster::raster(system.file("test_dsm.tif", package ="viewscape"))

# Load points (.shp file)
test_viewpoints <- sf::read_sf(system.file("test_viewpoints.shp", package = "viewscape"))

#Transform viewpoint from shape file to coordinates 
test_viewpoints <- sf::st_coordinates(test_viewpoints)

# Compute viewsheds
# the output includes binary matrix and extent of viewshed 
output <- viewscape::compute_viewshed(dsm = test_dsm, viewpoints = test_viewpoints, offset_viewpoint = 6, multiviewpoints = TRUE)
```

```{r}
# plot all viewsheds on DSM
# each <- output[5]
# raster_data <- raster::raster(each[[1]][[1]])
# raster::extent(raster_data) <- each[[1]][[2]]
# raster::res(raster_data) <- raster::res(test_dsm)
# raster_data[raster_data[] == 0 ] = NA
# raster::plot(raster_data, add=TRUE, col = "red", axes=FALSE, box=FALSE, legend = FALSE)
par(mfrow=c(3,3))
for(i in 1:length(output)) {
  each <- output[i]
  raster_data <- raster::raster(each[[1]][[1]])
  raster::extent(raster_data) <- each[[1]][[2]]
  raster::res(raster_data) <- raster::res(test_dsm)
  raster_data[raster_data[] == 0 ] = NA
  raster::plot(test_dsm, axes=FALSE, box=FALSE, legend = FALSE)
  raster::plot(raster_data, add=TRUE, col = "red", axes=FALSE, box=FALSE, legend = FALSE)
}
```

## Calculate viewscape

The function of view depth analysis can calculate two different metrics: the furthest distance and standard deviation of distances. To calculate view depth, there are two needed objects: the DSM that was used to get viewshed and result from viewshed analysis. Additionally, the third input parameter is used to customize the output.

The function of extent analysis can calculate the total area of viewshed and needs the DSM that was used to get viewshed and result from viewshed analysis. 

The following function can calculate the area of ground surface and standard deviation of elevations within a viewshed. The function needs a DSM and a DEM/DTM to calculate the metrics. Additionally, the third input parameter is used to customize the output.

```{r eval=FALSE}
  # calculate view depth within the viewshed
  test_depth <- viewscape::get_depth(test_visiblepoint, test_viewpoint, 3)
```


## calculate a single feature

To calculate canopy area in a viewshed, the DSM that was used to get viewshed and a raster of canopy are needed. Additionally, input parameter 'data' is used to indicate the type of input canopy raster and 'nodata' is used to indicate the the value of cells that don't have any canopy.

```{r eval=FALSE}
  # load canopy raster
  test_canopy <- raster::raster(system.file("test_data/test_canopy.tif",
                                            package ="viewscape"))
  # calculate the area of canopy
  test_canopy_area <- viewscape::calculate_canopy(data = 1, test_canopy, 
                                                  nodata = 0, test_dsm, 
                                                  test_visiblepoint)
```

## Calculate land use/cover diversity

The land use analysis calculates the percentage(%) of each type of land use in a viewshed. The DSM that was used to get viewshed, visible points, and a raster of land use are needed.
The land cover analysis calculates the areas of perviousness and imperviousness and percentages(%) of perviousness and imperviousness in a viewshed. The DSM that was used to get viewshed, visible points, and a raster of land cover are needed. Input parameters 'vegetation' and 'imperviousness' are used to indicate the code of perviousness including trees or grass and the code of imperviousness including buildings, parking, and roads.

```{r eval=FALSE}
  # load landuse raster
 test_landcover <- raster::raster(system.file("test_data/test_landcover.tif",
                                            package ="viewscape"))

  # calculate the areas and percentages of perviousness and imperviousness 
  # in the sample data of land cover, value 2 is for vegetation and value 4 is for imperviousness
  test_landcover_area <- viewscape::calculate_landcover(landcover = test_landcover, 
                                                        dsm = test_dsm,
                                                        visiblepoints = test_visiblepoint,
                                                        vegetation = 2, imperviousness = 4)
```

## calculate_landuse

```{r eval=FALSE}
  # load landuse raster
 test_landuse <- raster::raster(system.file("test_data/test_landuse.tif",
                                            package ="viewscape"))
  # calculate the percentage of each type of land use  
  test_landuse_area <- viewscape::calculate_landuse(landuse = test_landuse, 
                                                    dsm = test_dsm,
                                                    visiblepoints = test_visiblepoint)
```

## Get LiDAR data information via API 

```{r}
# search for lidar data information using bbox
search_result <- lidar_search(bbox = c(-83.742282,42.273389,-83.733442,42.278724), preview = TRUE)
```

```{r}
search_result
```

## Download LiDAR data with a given point and searching distance
```{r}
# try coordinates -83.741289,42.270146 (in south Michigan, USA)
# radius is 1000ft
las <- get_lidar(x = -83.741289, 
                 y = 42.270146, 
                 r = 1000, 
                 epsg = 2253,
                 folder = '/Users/yangxiaohao/Downloads/testfunction',
                 plot = FALSE)
```

```{r}
# Create DTM
lidR::classify_ground(las)
```

For more usages of lidR please refer: https://github.com/r-lidar/lidR/tree/master and https://rpubs.com/jesseast/lidR4smarties
